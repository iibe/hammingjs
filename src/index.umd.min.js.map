{"version":3,"file":"index.umd.min.js","sources":["index.ts"],"sourcesContent":["/**\n * Returns encoded binary string.\n */\nexport function encode(message: string): string {\n  if (!message.match(/^[01]+$/)) {\n    throw new Error(`Should be a binary string: ${message}`);\n  }\n\n  // find control bits positions\n  const controlBits: number[] = [];\n  while (\n    controlBits.length <\n    Math.ceil(Math.log2(message.length + controlBits.length + 1))\n  ) {\n    controlBits.push((1 << controlBits.length) - 1);\n  }\n\n  // transfort bitword to array for mutability\n  const bitword: string[] = [...message];\n\n  // insert control bits in bitword\n  for (const bit of controlBits) {\n    bitword.splice(bit, 0, \"0\");\n  }\n\n  // initialize a table of transformation\n  const table: string[][] = [\n    bitword,\n    ...Array.from({ length: controlBits.length }, () => []),\n  ];\n\n  // put col number (in binary format) at according col position\n  for (let col = 1; col <= bitword.length; col++) {\n    const binary: string = (col >>> 0)\n      .toString(2)\n      .padStart(controlBits.length, \"0\");\n    for (let row = 1; row <= controlBits.length; row++) {\n      table[row].push(binary[binary.length - row]);\n    }\n  }\n\n  // calculate matches for bitword with control bits\n  for (let row = 1; row < table.length; row++) {\n    let match: number = 0;\n    for (let col = 0; col < bitword.length; col++) {\n      if (table[row][col] === bitword[col] && bitword[col] === \"1\") {\n        match++;\n      }\n    }\n    bitword[controlBits[row - 1]] = (match % 2).toString();\n  }\n\n  return bitword.join(\"\");\n}\n\n/**\n * Detects error position in encoded message.\n */\nexport function detect(encoded: string): number {\n  if (!encoded.match(/^[01]+$/)) {\n    throw new Error(`Should be a binary string: ${encoded}`);\n  }\n\n  // find control bits positions\n  const controlBits: number[] = [];\n  while (\n    controlBits.length <\n    Math.ceil(Math.log2(encoded.length + controlBits.length + 1))\n  ) {\n    controlBits.push((1 << controlBits.length) - 1);\n  }\n\n  // transfort bitword to array for mutability\n  const bitword: string[] = [...encoded];\n\n  // initialize a table of transformation\n  const table: string[][] = [\n    bitword,\n    ...Array.from({ length: controlBits.length }, () => []),\n  ];\n\n  // put col number (in binary format) at according col position\n  for (let col = 1; col <= bitword.length; col++) {\n    const binary: string = (col >>> 0)\n      .toString(2)\n      .padStart(controlBits.length, \"0\");\n    for (let row = 1; row <= controlBits.length; row++) {\n      table[row].push(binary[binary.length - row]);\n    }\n  }\n\n  // error position in binary representation\n  const error: number[] = [];\n\n  // calculate matches for bitword with control bits\n  for (let row = 1; row < table.length; row++) {\n    let match: number = 0;\n    for (let col = 0; col < bitword.length; col++) {\n      if (table[row][col] === bitword[col] && bitword[col] === \"1\") {\n        match++;\n      }\n    }\n    error.push(match % 2);\n  }\n\n  // return error position\n  return parseInt(error.reverse().join(\"\"), 2) - 1;\n}\n\n/**\n * Returns decoded binary string message.\n */\nexport function decode(error: string): string {\n  const bug: number = detect(error);\n  const fix: string = error[bug] === \"0\" ? \"1\" : \"0\";\n  const err: string[] = [...error];\n  err[bug] = fix;\n  return [...err].join(\"\");\n}\n"],"names":["detect","encoded","match","Error","controlBits","length","Math","ceil","log2","push","bitword","table","Array","from","col","binary","toString","padStart","row","error","parseInt","reverse","join","bug","fix","err","message","bit","splice"],"mappings":"2QA0DM,SAAUA,EAAOC,GACrB,IAAKA,EAAQC,MAAM,WACjB,MAAM,IAAIC,MAAM,8BAA8BF,KAIhD,MAAMG,EAAwB,GAC9B,KACEA,EAAYC,OACZC,KAAKC,KAAKD,KAAKE,KAAKP,EAAQI,OAASD,EAAYC,OAAS,KAE1DD,EAAYK,MAAM,GAAKL,EAAYC,QAAU,GAI/C,MAAMK,EAAoB,IAAIT,GAGxBU,EAAoB,CACxBD,KACGE,MAAMC,KAAK,CAAER,OAAQD,EAAYC,SAAU,IAAM,MAItD,IAAK,IAAIS,EAAM,EAAGA,GAAOJ,EAAQL,OAAQS,IAAO,CAC9C,MAAMC,GAAkBD,IAAQ,GAC7BE,SAAS,GACTC,SAASb,EAAYC,OAAQ,KAChC,IAAK,IAAIa,EAAM,EAAGA,GAAOd,EAAYC,OAAQa,IAC3CP,EAAMO,GAAKT,KAAKM,EAAOA,EAAOV,OAASa,IAK3C,MAAMC,EAAkB,GAGxB,IAAK,IAAID,EAAM,EAAGA,EAAMP,EAAMN,OAAQa,IAAO,CAC3C,IAAIhB,EAAgB,EACpB,IAAK,IAAIY,EAAM,EAAGA,EAAMJ,EAAQL,OAAQS,IAClCH,EAAMO,GAAKJ,KAASJ,EAAQI,IAAyB,MAAjBJ,EAAQI,IAC9CZ,IAGJiB,EAAMV,KAAKP,EAAQ,GAIrB,OAAOkB,SAASD,EAAME,UAAUC,KAAK,IAAK,GAAK,WAM3C,SAAiBH,GACrB,MAAMI,EAAcvB,EAAOmB,GACrBK,EAA6B,MAAfL,EAAMI,GAAe,IAAM,IACzCE,EAAgB,IAAIN,GAE1B,OADAM,EAAIF,GAAOC,EACJ,IAAIC,GAAKH,KAAK,yBAlHjB,SAAiBI,GACrB,IAAKA,EAAQxB,MAAM,WACjB,MAAM,IAAIC,MAAM,8BAA8BuB,KAIhD,MAAMtB,EAAwB,GAC9B,KACEA,EAAYC,OACZC,KAAKC,KAAKD,KAAKE,KAAKkB,EAAQrB,OAASD,EAAYC,OAAS,KAE1DD,EAAYK,MAAM,GAAKL,EAAYC,QAAU,GAI/C,MAAMK,EAAoB,IAAIgB,GAG9B,IAAK,MAAMC,KAAOvB,EAChBM,EAAQkB,OAAOD,EAAK,EAAG,KAIzB,MAAMhB,EAAoB,CACxBD,KACGE,MAAMC,KAAK,CAAER,OAAQD,EAAYC,SAAU,IAAM,MAItD,IAAK,IAAIS,EAAM,EAAGA,GAAOJ,EAAQL,OAAQS,IAAO,CAC9C,MAAMC,GAAkBD,IAAQ,GAC7BE,SAAS,GACTC,SAASb,EAAYC,OAAQ,KAChC,IAAK,IAAIa,EAAM,EAAGA,GAAOd,EAAYC,OAAQa,IAC3CP,EAAMO,GAAKT,KAAKM,EAAOA,EAAOV,OAASa,IAK3C,IAAK,IAAIA,EAAM,EAAGA,EAAMP,EAAMN,OAAQa,IAAO,CAC3C,IAAIhB,EAAgB,EACpB,IAAK,IAAIY,EAAM,EAAGA,EAAMJ,EAAQL,OAAQS,IAClCH,EAAMO,GAAKJ,KAASJ,EAAQI,IAAyB,MAAjBJ,EAAQI,IAC9CZ,IAGJQ,EAAQN,EAAYc,EAAM,KAAOhB,EAAQ,GAAGc,WAG9C,OAAON,EAAQY,KAAK"}