{"version":3,"file":"index.esm.min.js","sources":["index.ts"],"sourcesContent":["/**\n * Returns encoded binary string.\n */\nexport function encode(message: string): string {\n  if (!message.match(/^[01]+$/)) {\n    throw new Error(`Should be a binary string: ${message}`);\n  }\n\n  // find control bits positions\n  const controlBits: number[] = [];\n  while (\n    controlBits.length <\n    Math.ceil(Math.log2(message.length + controlBits.length + 1))\n  ) {\n    controlBits.push((1 << controlBits.length) - 1);\n  }\n\n  // transfort bitword to array for mutability\n  const bitword: string[] = [...message];\n\n  // insert control bits in bitword\n  for (const bit of controlBits) {\n    bitword.splice(bit, 0, \"0\");\n  }\n\n  // initialize a table of transformation\n  const table: string[][] = [\n    bitword,\n    ...Array.from({ length: controlBits.length }, () => []),\n  ];\n\n  // put col number (in binary format) at according col position\n  for (let col = 1; col <= bitword.length; col++) {\n    const binary: string = (col >>> 0)\n      .toString(2)\n      .padStart(controlBits.length, \"0\");\n    for (let row = 1; row <= controlBits.length; row++) {\n      table[row].push(binary[binary.length - row]);\n    }\n  }\n\n  // calculate matches for bitword with control bits\n  for (let row = 1; row < table.length; row++) {\n    let match: number = 0;\n    for (let col = 0; col < bitword.length; col++) {\n      if (table[row][col] === bitword[col] && bitword[col] === \"1\") {\n        match++;\n      }\n    }\n    bitword[controlBits[row - 1]] = (match % 2).toString();\n  }\n\n  return bitword.join(\"\");\n}\n\n/**\n * Detects error position in encoded message.\n */\nexport function detect(encoded: string): number {\n  if (!encoded.match(/^[01]+$/)) {\n    throw new Error(`Should be a binary string: ${encoded}`);\n  }\n\n  // find control bits positions\n  const controlBits: number[] = [];\n  while (\n    controlBits.length <\n    Math.ceil(Math.log2(encoded.length + controlBits.length + 1))\n  ) {\n    controlBits.push((1 << controlBits.length) - 1);\n  }\n\n  // transfort bitword to array for mutability\n  const bitword: string[] = [...encoded];\n\n  // initialize a table of transformation\n  const table: string[][] = [\n    bitword,\n    ...Array.from({ length: controlBits.length }, () => []),\n  ];\n\n  // put col number (in binary format) at according col position\n  for (let col = 1; col <= bitword.length; col++) {\n    const binary: string = (col >>> 0)\n      .toString(2)\n      .padStart(controlBits.length, \"0\");\n    for (let row = 1; row <= controlBits.length; row++) {\n      table[row].push(binary[binary.length - row]);\n    }\n  }\n\n  // error position in binary representation\n  const error: number[] = [];\n\n  // calculate matches for bitword with control bits\n  for (let row = 1; row < table.length; row++) {\n    let match: number = 0;\n    for (let col = 0; col < bitword.length; col++) {\n      if (table[row][col] === bitword[col] && bitword[col] === \"1\") {\n        match++;\n      }\n    }\n    error.push(match % 2);\n  }\n\n  // return error position\n  return parseInt(error.reverse().join(\"\"), 2) - 1;\n}\n\n/**\n * Returns decoded binary string message.\n */\nexport function decode(error: string): string {\n  const bug: number = detect(error);\n  const fix: string = error[bug] === \"0\" ? \"1\" : \"0\";\n  const err: string[] = [...error];\n  err[bug] = fix;\n  return [...err].join(\"\");\n}\n"],"names":["encode","message","match","Error","controlBits","length","Math","ceil","log2","push","bitword","bit","splice","table","Array","from","col","binary","toString","padStart","row","join","detect","encoded","error","parseInt","reverse","decode","bug","fix","err"],"mappings":"AAGM,SAAUA,EAAOC,GACrB,IAAKA,EAAQC,MAAM,WACjB,MAAM,IAAIC,MAAM,8BAA8BF,KAIhD,MAAMG,EAAwB,GAC9B,KACEA,EAAYC,OACZC,KAAKC,KAAKD,KAAKE,KAAKP,EAAQI,OAASD,EAAYC,OAAS,KAE1DD,EAAYK,MAAM,GAAKL,EAAYC,QAAU,GAI/C,MAAMK,EAAoB,IAAIT,GAG9B,IAAK,MAAMU,KAAOP,EAChBM,EAAQE,OAAOD,EAAK,EAAG,KAIzB,MAAME,EAAoB,CACxBH,KACGI,MAAMC,KAAK,CAAEV,OAAQD,EAAYC,SAAU,IAAM,MAItD,IAAK,IAAIW,EAAM,EAAGA,GAAON,EAAQL,OAAQW,IAAO,CAC9C,MAAMC,GAAkBD,IAAQ,GAC7BE,SAAS,GACTC,SAASf,EAAYC,OAAQ,KAChC,IAAK,IAAIe,EAAM,EAAGA,GAAOhB,EAAYC,OAAQe,IAC3CP,EAAMO,GAAKX,KAAKQ,EAAOA,EAAOZ,OAASe,IAK3C,IAAK,IAAIA,EAAM,EAAGA,EAAMP,EAAMR,OAAQe,IAAO,CAC3C,IAAIlB,EAAgB,EACpB,IAAK,IAAIc,EAAM,EAAGA,EAAMN,EAAQL,OAAQW,IAClCH,EAAMO,GAAKJ,KAASN,EAAQM,IAAyB,MAAjBN,EAAQM,IAC9Cd,IAGJQ,EAAQN,EAAYgB,EAAM,KAAOlB,EAAQ,GAAGgB,WAG9C,OAAOR,EAAQW,KAAK,IAMhB,SAAUC,EAAOC,GACrB,IAAKA,EAAQrB,MAAM,WACjB,MAAM,IAAIC,MAAM,8BAA8BoB,KAIhD,MAAMnB,EAAwB,GAC9B,KACEA,EAAYC,OACZC,KAAKC,KAAKD,KAAKE,KAAKe,EAAQlB,OAASD,EAAYC,OAAS,KAE1DD,EAAYK,MAAM,GAAKL,EAAYC,QAAU,GAI/C,MAAMK,EAAoB,IAAIa,GAGxBV,EAAoB,CACxBH,KACGI,MAAMC,KAAK,CAAEV,OAAQD,EAAYC,SAAU,IAAM,MAItD,IAAK,IAAIW,EAAM,EAAGA,GAAON,EAAQL,OAAQW,IAAO,CAC9C,MAAMC,GAAkBD,IAAQ,GAC7BE,SAAS,GACTC,SAASf,EAAYC,OAAQ,KAChC,IAAK,IAAIe,EAAM,EAAGA,GAAOhB,EAAYC,OAAQe,IAC3CP,EAAMO,GAAKX,KAAKQ,EAAOA,EAAOZ,OAASe,IAK3C,MAAMI,EAAkB,GAGxB,IAAK,IAAIJ,EAAM,EAAGA,EAAMP,EAAMR,OAAQe,IAAO,CAC3C,IAAIlB,EAAgB,EACpB,IAAK,IAAIc,EAAM,EAAGA,EAAMN,EAAQL,OAAQW,IAClCH,EAAMO,GAAKJ,KAASN,EAAQM,IAAyB,MAAjBN,EAAQM,IAC9Cd,IAGJsB,EAAMf,KAAKP,EAAQ,GAIrB,OAAOuB,SAASD,EAAME,UAAUL,KAAK,IAAK,GAAK,EAM3C,SAAUM,EAAOH,GACrB,MAAMI,EAAcN,EAAOE,GACrBK,EAA6B,MAAfL,EAAMI,GAAe,IAAM,IACzCE,EAAgB,IAAIN,GAE1B,OADAM,EAAIF,GAAOC,EACJ,IAAIC,GAAKT,KAAK"}