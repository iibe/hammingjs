function t(t){if(!t.match(/^[01]+$/))throw new Error(`Should be a binary string: ${t}`);const n=[];for(;n.length<Math.ceil(Math.log2(t.length+n.length+1));)n.push((1<<n.length)-1);const e=[...t];for(const t of n)e.splice(t,0,"0");const o=[e,...Array.from({length:n.length},(()=>[]))];for(let t=1;t<=e.length;t++){const e=(t>>>0).toString(2).padStart(n.length,"0");for(let t=1;t<=n.length;t++)o[t].push(e[e.length-t])}for(let t=1;t<o.length;t++){let r=0;for(let n=0;n<e.length;n++)o[t][n]===e[n]&&"1"===e[n]&&r++;e[n[t-1]]=(r%2).toString()}return e.join("")}function n(t){if(!t.match(/^[01]+$/))throw new Error(`Should be a binary string: ${t}`);const n=[];for(;n.length<Math.ceil(Math.log2(t.length+n.length+1));)n.push((1<<n.length)-1);const e=[...t],o=[e,...Array.from({length:n.length},(()=>[]))];for(let t=1;t<=e.length;t++){const e=(t>>>0).toString(2).padStart(n.length,"0");for(let t=1;t<=n.length;t++)o[t].push(e[e.length-t])}const r=[];for(let t=1;t<o.length;t++){let n=0;for(let r=0;r<e.length;r++)o[t][r]===e[r]&&"1"===e[r]&&n++;r.push(n%2)}return parseInt(r.reverse().join(""),2)-1}function e(t){const e=n(t),o="0"===t[e]?"1":"0",r=[...t];return r[e]=o,[...r].join("")}console.log("Hamming.js");export{e as decode,n as detect,t as encode};
